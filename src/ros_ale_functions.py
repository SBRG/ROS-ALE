"""
Functions for ROS TALE Manuscript
"""
__author__ = 'Kevin Rychel'
__email__ = 'krychel@eng.ucsd.edu'


############
## Set Up ##
############

# import general packages
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns

# iModulon functions; see PyModulon documentation
# github.com/SBRG/pymodulon
from pymodulon.io import *
from pymodulon.plotting import *

# import some more specific functions
from matplotlib.colors import to_rgba

# modify matplotlib settings for output
matplotlib.rcParams['pdf.fonttype'] = 42
matplotlib.rcParams['ps.fonttype'] = 42
matplotlib.rcParams['svg.fonttype'] = 'none'
matplotlib.rcParams['font.sans-serif'] = 'Arial'
matplotlib.rcParams['font.family'] = 'sans-serif'
sns.set_style('ticks')
matplotlib.rcParams['text.color'] = '#000000'
matplotlib.rcParams['axes.labelcolor'] = '#000000'
matplotlib.rcParams['xtick.color'] = '#000000'
matplotlib.rcParams['ytick.color'] = '#000000'

######################
## Helper Functions ##
######################

def get_ev_strains(ros_meta):
    """
    Get a list of all the evolved strains
    
    Parameter
    ---------
    ros_meta: metadata for the samples
    
    Returns
    -------
    strains: list of strains
    """
    
    strains = ros_meta.lineage.unique()
    strains = [i for i in strains if not('0_0' in i)]
    strains = [i for i in strains if not('mid' in i)]
    
    return strains

# input: ros_meta
#        lineages, a list of lineages, e.g. ['0_0', '1_0']
#        pq, a list of paraquat concentrations, e.g. [0, 250]
# output: a list of samples in the desired conditions
def get_samples(ros_meta, lineages, pq):
    """
    Gets sample names for the given condition
    
    Parameters
    ----------
    ros_meta: metadata for the samples
    lineages: a list of strains, e.g. ['0_0', '1_0']
    pq: a list of paraquat concentrations, e.g. [0, 250]
    
    Returns
    -------
    samples: a Pandas series of sample names
    
    """
    
    lin_bool = ros_meta.lineage.isin(lineages)
    pq_bool = ros_meta.pq.isin(pq)
    series = ros_meta.index
    return series[lin_bool & pq_bool]

def get_pq_dicts():
    """
    Returns dictionaries for PQ plot settings
    
    Returns
    -------
    pq_color: colors for each PQ value
    pq_marker: marker shapes for each PQ value
    """
    pq_marker = {0:'o',
                 250: 's',
                 750: '^'}
    pq_color = {0: 'tab:blue',
                125: '#6D6CBA',
                250: 'tab:purple', 
                750:'tab:red'}
    pq_color = {k:to_rgba(v) for k, v in pq_color.items()}
    
    return pq_color, pq_marker

def get_mutations(all_mutations, gene):
    """
    Gets the set of mutations affecting a gene

    Parameters
    ----------
    all_mutations: table of mutations
    gene: name of gene, e.g. 'emrE'

    Returns
    -------
    mutations: Pandas DataFrame with details for relevant mutations
    """
    muts = []
    for i, row in all_mutations.iterrows():
        mut_genes = row.Gene.split(', ')
        if gene in mut_genes:
            muts += [i]
    return all_mutations.loc[muts]
    
def main_plotter(data, sample_dict, axis_label, ax, orientation,
                 dodge, legend, legendsize, labelsize, ticksize, 
                 errwidth, pointsize, x_rot, zerolinewidth):
    """
    See im_bar_swarm(), met_bar_swarm(), and special_bar_swarm()
    Helper function for the most common type of plot in the paper,
    which features strain categories on one axis and a value on the other
    and is colored by PQ level.
    
    Parameters
    ----------
    data: DataFrame with columns: ['x_label', 'y', 'Lineage', 'PQ']
        and rows corresponding to data points. Generated by the wrapper 
        functions.
    sample_dict: dictionary from labels to sample lists. Generated by the 
        wrapper functions.
    axis_label: label for the non-categorical axis
    orientation: 'horizontal' or 'vertical'
    dodge: Whether to separate each PQ level into different bars
    legend: Whether to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    pointsize: point size for swarm plot
    x_rot: rotation of x axis labels
    zerolinewidth: width of the line at 0
    
    Returns
    -------
    ax: axes with plot
    """
    
    # create axes if necessary
    if ax is None:
        fig, ax = plt.subplots(figsize = (0.75, 1.5),
                               dpi = 140)
    
    # define labels & columns based on orientation
    if not orientation in ['horizontal', 'vertical']:
        print('assuming vertical',
              '(else enter orientation = "horizontal")')
        orientation = 'vertical'
    if orientation == 'horizontal':
        x, y = 'y', 'x_label'
        x_label, y_label = axis_label, ''
        ticksize_adjust = 'x'
        ax.axvline(color = 'k', linewidth = zerolinewidth)
    elif orientation == 'vertical':
        x, y = 'x_label', 'y'
        y_label, x_label = axis_label, ''
        ticksize_adjust = 'y'
        ax.axhline(color = 'k', linewidth = zerolinewidth)
        
    # get PQ settings
    pq_color, _ = get_pq_dicts()
    
    # draw plots based on dodge setting
    if dodge:
        """
        ax = sns.boxplot(x = x, y = y, data = data, 
                         hue = 'PQ', palette = pq_color,
                         ax = ax, linewidth = 0.5, fliersize = 0,
                         boxprops = {'alpha': 0.5},
                         medianprops = {'linewidth':2})
        """
        ax = sns.barplot(x = x, y = y, data = data, 
                         hue = 'PQ', palette = pq_color,
                         ax = ax, alpha = 0.7, errwidth = errwidth,
                         linewidth = 0.5, edgecolor = 'k')
        ax = sns.stripplot(x = x, y = y, data = data, 
                           hue = 'PQ', palette = pq_color,
                           s = pointsize, ax = ax, dodge = True,
                           jitter = 0.2)
    else:
        """
        ax = sns.boxplot(x = x, y = y, data = data, 
                         color = 'tab:gray', ax = ax, linewidth = 0.5,
                         fliersize = 0, boxprops = {'alpha': .5},
                         medianprops = {'linewidth':2})
        """
        ax = sns.barplot(x = x, y = y, data = data, 
                         color = 'tab:gray',
                         ax = ax, alpha = 0.5, errwidth = errwidth,
                         linewidth = 0.5, edgecolor = 'k')
        ax = sns.stripplot(x = x, y = y, data = data, 
                           hue = 'PQ', palette = pq_color,
                           s = pointsize, ax = ax, dodge = False,
                           jitter = 0.2)
        
    # deal with the legend
    l = ax.legend(bbox_to_anchor = (1,1),loc = 'upper left', 
                  fontsize = legendsize, title = 'PQ (Î¼M)')
    plt.setp(l.get_title(), fontsize=legendsize)
    if legend == False:
        l.remove()
    
    # ticks and labels
    ax.tick_params(labelsize = labelsize)
    ax.tick_params(ticksize_adjust, labelsize = ticksize)
    ax.set_ylabel(y_label, fontsize = labelsize)
    ax.set_xlabel(x_label, fontsize = labelsize)
    if x_rot != 0:
        ax.tick_params('x', rotation = x_rot)
    
    return ax

####################
## iModulon Plots ##
####################

def im_bar_swarm(ica, ros_meta, k, strain_dict = None, ax = None,
              orientation = 'vertical', dodge = True, legend = False,
              legendsize = 7, labelsize = 7, ticksize = 7, 
              errwidth = 1.5, pointsize = 1.5, x_rot = 90,
              zerolinewidth = 0.5):
    """
    Generates bar/swarm plots for iModulon activities
    Relies on seaborn's bar and swarm functions
    Uses main_plotter() helper function
    
    Parameters
    ----------
    ica, ros_meta: main object & metadata
    k: iModulon name
    strain_dict: dictionary with labels pointing to lists of strains
                 default: start vs. evolved
    ax: axes to plot to (will create one if not provided)
    orientation: 'horizontal' or 'vertical'
    dodge: Whether to separate each PQ level into different bars
    legend: Whether to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    pointsize: point size for swarm plot
    x_rot: rotation of x axis labels
    zerolinewidth: width of the line at 0
    
    Returns
    -------
    ax: axes with plot
    """
    
    # organize groups of strains
    if strain_dict is None:
        strain_dict = {'Start':['0_0'],
                       'Evolved':get_ev_strains(ros_meta)}
    sample_dict = {label: get_samples(ros_meta, strains, [0, 250, 750]) 
                   for label, strains in strain_dict.items()}

    # make data table for seaborn
    data = pd.DataFrame(columns = ['x_label', 'y', 'Lineage', 'PQ'])
    for label, samples in sample_dict.items():
        for s in samples:
            data.loc[s] = [label, ica.A.loc[k, s], 
                           ros_meta.lineage[s],
                           ros_meta.pq[s]]
    
    # label the axis
    axis_label = k + ' iModulon Activity'
    
    # use my main plotting function
    ax =  main_plotter(data, sample_dict, axis_label, ax,
                       orientation, dodge, legend, legendsize,
                       labelsize, ticksize, errwidth, pointsize,
                       x_rot, zerolinewidth)
    return ax

def iM_pie(ica, ros_meta, k, iM_name, fontsize = 7,
           ax_size = 0.4, linewidth = 0.25):
    """
    Generates a pie chart of gene mutations for Figures 2 and 5A
    
    Parameters
    ----------
    mutations, ros_meta: set of mutations and metadata, respectively
    k: name of iModulon, matching ica object
    iM_name: the label for the pie chart
    fontsize: for gene label
    ax_size: edge length of the square axes in inches
    linewidth: width of white lines between pie slices
    
    Returns
    -------
    ax: axes with plot
    patches, texts: output of matplotlib.ax.pie() for editing
    """
    
    # get activity
    A_k = ica.A.loc[k]

    # center the data on reference
    ref_samples = get_samples(ros_meta, ['0_0'], [250])
    center = ica.A.loc[k, ref_samples].mean()
    A_k_norm = A_k - center

    # calculate the ends of the color scale
    sd = A_k_norm.std()
    sd_scale = 3
    vmin, vmax = -sd*sd_scale, sd*sd_scale

    # set up to convert means to colors
    cmap = matplotlib.cm.get_cmap('coolwarm')
    norm = matplotlib.colors.Normalize(vmin, vmax)

    # compute mean activities for each pie slice and convert to colors
    strains = get_ev_strains(ros_meta)
    res = pd.DataFrame(index = strains, columns = ['avg', 'color'])
    for s in strains:
        mean = A_k_norm.loc[get_samples(ros_meta, [s], [750])].mean()
        res.loc[s] = [mean, cmap(norm(mean))]
    
    # setup first generation slices to jut out
    ones = [1]*len(strains)
    explode = [0.25 if ('0' in s) else 0 for s in strains]
    
    # draw the pie chart
    fig, ax = plt.subplots(figsize = (ax_size, ax_size), dpi = 140)
    patches, texts = ax.pie(ones, colors = res.color, explode = explode,
                 wedgeprops = {'linewidth':linewidth})
    ax.set_title(iM_name, fontsize = fontsize)
    
    return ax, patches, texts

def ros_scatter(ica, ros_meta, im1, im2, names = None,
                groups = None, colors = None, pq = [0, 250, 750],
                ax = None, other_ros_label = 'Other ROS ALE Samples',
                include_mid = False, include_nonros = True,
                add_parent_arrow = True, legend = True,
                all_markers_in_legend = False, s_scale = 1):
    """
    Generates scatter plot of iModulon activities for scatter_swarm()
    
    Parameters
    ----------
    ica, ros_meta: main object & metadata
    im1, im2: iModulon indices for x and y axes
    names: replace iModulon indices with these unless == ''
    groups: dict with a group name pointing to list of strains
           ex: {'iscR V55L': ['1_X'], 'iscR T106P': ['3_1']}
           replace the last character with 'X' to include all
    colors: dict with same keys as groups pointing to colors. 
           Defaults provided if None
    pq: list of paraquat concentrations to plot, default all
    other_ros_label: if using groups, this label will be used 
                    for anything not in the group. To not show
                    anything that isn't in a group, set to None.
    include_mid: whether to plot the midpoints 1_mid and 2_mid.
               Only relevant if those samples aren't in a group.
    include_nonros: whether to put all of precise-1k in the backround
                  of the plot.
    add_parent_arrow: if True, adds the 0 and 250 pq locations of 
                     the parent strain with an arrow between them
                     to indicate the direction of ROS's effect.
    ax: axis to plot on (will create one if None)
    legend: whether to include a legend
    all_markers_in_legend: displays all pq markers, regardless of 
                         which are used. If false, only display
                         the ones we used.
    output: ax, scatter plot axes
    """
    
    # adjust the names
    if names is None:
        names = [im1, im2]

    # use the midpoints?
    if include_mid:
        all_strains = ros_meta.lineage.unique()
        all_strains = all_strains[all_strains != '0_0']
    else:
        all_strains = get_ev_strains(ros_meta)

    if add_parent_arrow:
        all_strains = list(all_strains) + ['0_0']

    # handle groupings
    if not(groups is None):
        # invert the groups variable
        invert_groups = {}
        for g, str_list in groups.items():
            for s in str_list:
                if not('X' in s): # can use '1_X' to easily grab all 1 strains
                    invert_groups[s] = g
                else:
                    lineage_list = [i for i in get_kg_strains(ros_meta) if s[:2] in i]
                    for i in lineage_list:
                        invert_groups[i] = g
        # set other_ros_label = None if you want to hide the samples not in groups
        # else use a string and all other ROS samples will be labeled with that
        if not(other_ros_label is None):
            for s in all_strains:
                if not(s in invert_groups):
                    invert_groups[s] = other_ros_label
        # make sure '0_0' gets to be in there... There may be cases where 
        # this is unwanted
        # so I may have to edit here
        invert_groups['0_0'] = 'Parent Strain'

        # get the group colors
        if colors is None:
            default_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',
                              'tab:purple', 'tab:brown', 'tab:pink', 'cyan',
                              'tab:olive', 'tab:cyan', 'blue', 'salmon', 'lime',
                              'orangered', 'darkmagenta']
            colors = {}
            for g, c in zip(groups.keys(), default_colors):
                colors[g] = c
            colors['Parent Strain'] = 'k'
            colors[other_ros_label] = 'tab:gray'
        elif not(other_ros_label is None):
            if not(other_ros_label in colors.keys()):
                colors[other_ros_label] = 'tab:gray'
            if not('Parent Strain' in colors.keys()):
                colors['Parent Strain'] = 'k'

    else:
        # make a simple invert_groups dict
        invert_groups = {s:s for s in all_strains}
        invert_groups['0_0'] = 'Parent Strain'
        # add the colors
        if colors is None:
            colors = {'Parent Strain': 'black', '1_0': '#69fcff', '1_1': '#5db1de', '1_2': '#166791',
                 '1_3': '#4273d6', '1_4': '#0039ad', '2_0': '#8cff66', '2_1': '#46c43f',
                 '2_2': '#179110', '2_3': '#056b26', '3_0': '#ffbaed', '3_1': '#e079c5',
                 '3_2': '#ed32bc', '3_3': '#a471d1', '3_4': '#702cab', '1_mid': '#97bbd1',
                 '2_mid': '#9ab5a0'}

    # organize samples
    samples = pd.Series()
    for s in ica.A.columns:
        if s in ros_meta.index:
            if ros_meta.lineage[s] in invert_groups.keys():
                if ros_meta.pq[s] in pq:
                    samples.loc[s] = ros_meta.lineage[s] + ' ' + str(ros_meta.pq[s])
                elif (ros_meta.lineage[s] == '0_0' and add_parent_arrow):
                    samples.loc[s] = ros_meta.lineage[s] + ' ' + str(ros_meta.pq[s])
            elif include_nonros: 
                samples[s] = 'Other Samples'
        elif include_nonros:
            samples[s] = 'Other Samples'

    # add style
    pq_marker = {0:'o',
                 250: 's',
                 750: '^'}
    style = pd.DataFrame(index = samples.unique(), columns = ['color', 'marker', 'zorder'])
    for name in style.index:
        if name == 'Other Samples':
            style.loc[name] = ['#e3e3e3', 'o', 1]
        else:
            parts = name.split(' ')
            style.marker[name] = pq_marker[int(parts[1])]
            style.color[name] = colors[invert_groups[parts[0]]]
            style.zorder[name] = 3
            if style.color[name] == 'tab:gray':
                style.zorder[name] = 2

    # plot
    if ax is None:
        fig, ax = plt.subplots(figsize = (7,6))

    for name, group in samples.groupby(samples):
        s = int(36*s_scale)
        if style.zorder[name] == 3:
            s = int(64*s_scale)
        ax.scatter(ica.A.loc[im1, group.index], 
                   ica.A.loc[im2, group.index],
                   zorder = style.zorder[name], s = s,
                   marker = style.marker[name], c = style.color[name])

    # add an arrow to indicate direction of ROS if desired
    if add_parent_arrow:
        p_0pq = get_samples(ros_meta, ['0_0'], [0])
        p_250pq = get_samples(ros_meta, ['0_0'], [250])
        x_start = ica.A.loc[im1, p_0pq].mean()
        y_start = ica.A.loc[im2, p_0pq].mean()
        x_end = ica.A.loc[im1, p_250pq].mean() - x_start
        y_end = ica.A.loc[im2, p_250pq].mean() - y_start
        ax.arrow(x_start, y_start, x_end, y_end, color = colors['Parent Strain'],
                 width = 0.005, length_includes_head = True, head_width = 0.5,
                 overhang = 0.5, zorder = 5)
    
    # axes labels
    ax.set_xlabel(names[0] + ' Activity', fontsize = 7)
    ax.set_ylabel(names[1] + ' Activity', fontsize = 7)

    # legend
    if legend:
        from matplotlib.lines import Line2D
        elts = []
        for g in pd.Series(invert_groups.values()).unique():
            elts += [Line2D([0], [0], color = colors[g], marker = 'o', 
                            linestyle = 'None', label = g, markersize = 15)]

        if include_nonros:
            elts +=[Line2D([0], [0], color = 'lightgray', marker = 'o',
                           linestyle = 'None', label = 'Other Samples',
                           markersize = 15)]
        if all_markers_in_legend:
            pq = [0, 250, 750]
        for p in pq:
            elts += [Line2D([0], [0], color = 'tab:gray', marker = pq_marker[p], linestyle = 'None',
                            label = str(p) +' uM PQ', markersize = 15)]
        ax.legend(handles = elts, bbox_to_anchor = (1, 1), fontsize = 16, ncol = (len(elts)//11 + 1))
    return ax

def scatter_swarm(ica, ros_meta, im_x, im_y, 
              strain_dict = None, colors = None, fig = None,
              legendsize = 7, labelsize = 7, ticksize = 7,
              errwidth = 1.5, zerolinewidth = 0.5):
    """
    Generates a scatter plot of two iModulon activities with bar/swarm
    plots on each axis
    
    Parameters
    ----------
    ica, ros_meta: main_object & metadata
    im_x, im_y = iModulon name for each axis
    strain_dict: dictionary with labels pointing to lists of strains
                 default: start vs. evolved
    colors: dictionary with colors for each entry in strain_dict
    fig: fig to plot to (will create one if not provided)
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    zerolinewidht: width of the line at 0
    
    Returns
    -------
    axs: the axes for the plot
    """
    
    # generate the subplot axs
    if fig is None:
        fig, axs = plt.subplots(2,2, figsize = (2.6, 2.3), dpi = 160,
                              gridspec_kw = {'height_ratios': [1.2,2],
                                            'width_ratios': [2,1],
                                            'wspace': 0,
                                            'hspace': 0})
    else:
        axs = fig.subplots(2,2,gridspec_kw = {'height_ratios': [1.2,2],
                                            'width_ratios': [2,1],
                                            'wspace': 0,
                                            'hspace': 0})
    axs[0][1].axis('off')
    
    # organize strains and colors
    if strain_dict is None:
        strain_dict = {'Start':['0_0'],
                       'Evolved':strains}
        colors = {'Start':'k',
                  'Evolved':'tab:green'}
    if colors is None:
        def_colors = ['tab:blue', 'tab:orange', 'tab:green',
                      'tab:red', 'tab:purple', 'tab:brown',
                      'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']
        colors = dict(zip(strain_dict.keys(), def_colors))
    
    # generate the bar plot for im_y
    im_bar_swarm(ica, ros_meta, im_y, strain_dict,
              ax = axs[1,1], pointsize = 1.5,dodge = False,
              legendsize = legendsize, labelsize = labelsize, 
              ticksize = ticksize, x_rot = 90, errwidth = errwidth,
              zerolinewidth = zerolinewidth)
    axs[1,1].yaxis.tick_right()
    axs[1,1].yaxis.set_label_position("right")
    axs[1,1].legend('', )

    # generate the bar plot for im_x
    im_bar_swarm(ica, ros_meta,im_x, strain_dict, ax = axs[0,0],
                 orientation = 'horizontal', dodge = False,
                 pointsize = 1.5, legendsize = legendsize,
                 labelsize = labelsize, ticksize = ticksize,
                 errwidth = errwidth, zerolinewidth = zerolinewidth)
    axs[0,0].xaxis.tick_top()
    axs[0,0].xaxis.set_label_position("top")

    # use this function to generate the scatter plot
    ros_scatter(ica, ros_meta, im_x, im_y, groups = strain_dict,
                colors = colors,
                legend = False, ax = axs[1,0], s_scale = .05)

    # add lines
    axs[1,0].axvline(color = 'k', linewidth = zerolinewidth,
        zorder = -1)
    axs[1,0].axhline(color = 'k', linewidth = zerolinewidth,
        zorder = -1)
    
    # clean up
    axs[0,0].set_xlim(axs[1,0].get_xlim())
    axs[1,1].set_ylim(axs[1,0].get_ylim())
    axs[1,0].tick_params(labelsize = ticksize)
    axs[1,0].set_xlabel('%s iModulon Activity'%(im_x), fontsize = labelsize)
    axs[1,0].set_ylabel('%s iModulon Activity'%(im_y), fontsize = labelsize)
    return axs

###########################
## Gene Expression Plots ##
###########################
def gene_bar_swarm(ica, ros_meta, g, strain_dict = None, ax = None,
              orientation = 'vertical', dodge = True, legend = False,
              legendsize = 7, labelsize = 7, ticksize = 7, 
              errwidth = 1.5, pointsize = 1.5, x_rot = 90,
              zerolinewidth = 0.5):
    """
    Generates bar/swarm plots for gene expression values
    Relies on seaborn's bar and swarm functions
    
    Parameters
    ----------
    ica, ros_meta: main object & metadata
    g: gene locus tag
    strain_dict: dictionary with labels pointing to lists of strains
                 default: start vs. evolved
    ax: axes to plot to (will create one if not provided)
    orientation: 'horizontal' or 'vertical'
    dodge: Whether to separate each PQ level into different bars
    legend: Whether to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    pointsize: point size for swarm plot
    x_rot: rotation of x axis labels
    zerolinewidth: width of the line at 0
    
    Returns
    -------
    ax: axes with plot
    """
    
    # organize groups of strains
    if strain_dict is None:
        strain_dict = {'Start':['0_0'],
                       'Evolved':get_ev_strains(ros_meta)}
    sample_dict = {label: get_samples(ros_meta, strains, [0, 250, 750]) 
                   for label, strains in strain_dict.items()}

    # make data table for seaborn
    data = pd.DataFrame(columns = ['x_label', 'y', 'Lineage', 'PQ'])
    for label, samples in sample_dict.items():
        for s in samples:
            data.loc[s] = [label, ica.X.loc[g, s], 
                           ros_meta.lineage[s],
                           ros_meta.pq[s]]
    
    axis_label = ica.num2name(g) + ' Expression'
    
    # use my main plotting function
    ax =  main_plotter(data, sample_dict, axis_label, ax,
                       orientation, dodge, legend, legendsize,
                       labelsize, ticksize, errwidth, pointsize,
                       x_rot, zerolinewidth)
    
    return ax



####################
## Mutation Plots ##
####################

def mut_color_table(all_mutations, ros_meta, genes, label_df,
                    ax, fontsize = 7, skip_muts = []):
    """
    Generates colored mutation heatmap for a set of genes.
    The labels need to be added to the plot in Adobe Illustrator,
        so they are output as a separate table here.

    Parameters
    ----------
    all_mutations: table of mutations
    ros_meta: metadata for this study
    genes: list of gene names
    label_df: table matching mutation names to their shorter labels and types
    ax: axes to plot to
    fontsize: fontsize applied to all labels
    skip_muts: mutation names to ignore

    Returns
    -------
    ax: axes with plot
    labeled_table: table with labels
    """

    # get the set of mutations
    muts = []
    for g in genes:
        g_muts = get_mutations(all_mutations, g)
        muts += g_muts.index.to_list()

    # use this to color code the heatmap
    # a default of 7 or any other unused value below 10 is fine
    label_colors = {'SNP': 0, #'tab:blue',
                  'upstream': 2, #'tab:green', 
                  'amp': 4, #'tab:purple', 
                  'frameshift': 1, #'tab:orange',
                  'del': 3,
                  'deletion': 3,
                  'nonsense SNP': 5,
                  'insertion': 8}

    # prepare tables
    strains = get_ev_strains(ros_meta)
    labeled_table = pd.DataFrame('', index = genes, columns = strains)
    t_hmap_val = pd.DataFrame(7, index = genes, columns = strains)

    # fill in tables
    for g in genes:
        g_muts = get_mutations(all_mutations, g)
        for m in g_muts.index:
            if m in skip_muts:
                continue
            for s in strains:
                if g_muts.loc[m, s]:
                    # account for multiple mutations in same gene
                    if len(labeled_table.loc[g, s]) > 0:
                        labeled_table.loc[g, s] = ', '.join([labeled_table.loc[g, s], 
                            label_df.label[m]])
                    else:
                        labeled_table.loc[g, s] = label_df.label[m]
                    # heatmap will only be colored by last mut type observed
                    # be careful of this when labeling in Illustrator
                    t_hmap_val.loc[g, s] = label_colors[label_df.type[m]]

    # make the heatmap
    sns.heatmap(t_hmap_val, cmap = sns.color_palette('tab10'), 
                vmin = 0, vmax = 10, annot = False, ax = ax,
                cbar = False, xticklabels = 1, yticklabels = 1)

    # change fontsizes
    ax.set_yticklabels(ax.get_yticklabels(), fontsize = fontsize)
    ax.set_xticklabels(ax.get_xticklabels(), fontsize = fontsize)

    return ax, labeled_table

def mut_pie(mutations, ros_meta, g, g_name, drop = [], 
            color = 'tab:green', fontsize = 7, ax_size = 0.4, 
            linewidth = 0.25):
    """
    Generates a pie chart of gene mutations for Figures 2 and 5A
    
    Parameters
    ----------
    mutations, ros_meta: set of mutations and metadata, respectively
    g: string or list of strings for gene names to include 
            (e.g. 'emrE' | ['arcA','arcB'])
    g_name: the label for the pie chart (e.g. 'emrE' | 'arcAB')
    drop: indices of mutations to ignore (not used)
    color: color to use for mutant allele pie slices
    fontsize: for gene label
    ax_size: edge length of the square axes in inches
    linewidth: width of white lines between pie slices
    
    Returns
    -------
    ax: axes with plot
    patches, texts: output of matplotlib.ax.pie() for editing
    """
    # get the set of mutations
    if isinstance(g, str):
        g = [g]
    mut_df = pd.concat([get_mutations(mutations, gene) for gene in g])

    # organize results & drop any unwanted mutations
    s_mut_df = mut_df[get_ev_strains(ros_meta)]
    if len(drop)>0:
        s_mut_df = s_mut_df.drop(drop)
    to_color = s_mut_df.any()

    # alleles --> colors
    color_dict = {True: color,
                  False: 'lightgray'}
    colors = to_color.map(color_dict)

    # setup first generation slices to jut out
    ones = [1]*s_mut_df.shape[1]
    explode = [0.25 if ('0' in s) else 0 for s in s_mut_df.columns]

    # draw the pie chart
    fig, ax = plt.subplots(figsize = (ax_size, ax_size), dpi = 140)
    patches, texts = ax.pie(ones, colors = colors, explode = explode,
                     wedgeprops = {'linewidth': linewidth})
    ax.set_title(g_name, fontsize = fontsize)

    return ax, patches, texts

###########################
## Genome Coverage Plots ##
###########################

def read_gff(gff_file, left, right, scale):
    """
    Reads GFF file for genome_plot()
    
    Parameters
    ----------
    gff_file: path to gff file to read
    left, right: integer bounds for genome location
    scale: whether to normalize to the max observed coverage
    
    Returns
    -------
    plus, minus: pandas Series of coverage by nucleotide sequence
                 for each strand
    """
    
    # sometimes the first line is a comment which pandas can't handle
    skiprows = 0
    with open(gff_file, "r") as infile:
        if infile.read(1) == "#":
            skiprows = 1
    table = pd.read_table(gff_file, header=None,
        usecols=[0, 2, 3, 4, 5, 6], comment="#", skiprows=skiprows,
        names=["chromosome", "name", "leftpos", "rightpos", 
               "reads", "strand"])
    table = table[(table.rightpos >= left) & (table.leftpos <= right)]
    
    if (table.leftpos != table.rightpos).any():
        print('Need to account for each line not being a single point')
        
    table = table[["leftpos", "reads", "strand"]]
    table_plus = table[table.strand == "+"].set_index("leftpos")
    table_minus = table[table.strand == "-"].set_index("leftpos")
    
    # fill missing values with 0
    filler = pd.Series([range(left, right + 1)], 
                       [range(left, right + 1)])
    table_plus["filler"] = 1
    table_minus["filler"] = 1
    table_plus.fillna(0)
    table_minus.fillna(0)
    
    # extract only the series we need
    plus = table_plus.reads
    minus = table_minus.reads.abs()  # in case stored negative
    if scale:
        plus *= 100. / plus.max()
        minus *= 100. / minus.max()
    
    # downsample to 2000 pts
    collapse_factor = int((right - left) / 2000)
    if collapse_factor > 1:
        plus = plus.groupby(lambda x: x // collapse_factor).mean()
        plus.index *= collapse_factor
        minus = minus.groupby(lambda x: x // collapse_factor).mean()
        minus.index *= collapse_factor

    return plus, minus

def genome_plot(gff_file, left, right, ymax = None,
                ax = None, fontsize = 7, ylabel = 'Coverage',
                scale = False, legend = True):
    
    """
    Generates filled plots for genome coverage from DNAseq
    
    Parameters
    ----------
    gff_file: path to gff file to read
    left, right: integer bounds for genome location
    ymax: if provided, set y axis bounds to [0, ymax]
    ax: axes to plot to (will create if not provided)
    fontsize: fontsize for all text
    ylabel: ylabel to use
    scale: whether to normalize to the max observed coverage
    legend: whether to include a legend
    
    Returns
    -------
    ax: axes with plot
    """
    
    # read gff file
    final_plus, final_minus = read_gff(gff_file, left, right, scale)
    
    # generate axes if necessary
    if ax is None:
        fig, ax = plt.subplots(figsize = (4, 1.5), dpi = 140)
    
    # draw plots
    ax.fill_between(final_minus.index, 0, final_minus.values, 
                    color = 'tab:orange', label = 'minus', 
                    alpha = 0.75)
    ax.fill_between(final_plus.index, 0, final_plus.values,
                    color = 'blue', label = 'plus', alpha = 0.5)
    
    # clean up appearance
    ax.set_xlim(left, right)
    ax.set_xlabel('Genome', fontsize = fontsize)
    ax.set_ylabel(ylabel, fontsize = fontsize)
    ax.tick_params(labelsize = fontsize)
    ax.ticklabel_format(axis="x", style="sci", scilimits=(1, 3))
    if legend:
        ax.legend(fontsize = fontsize, title = 'Strand', 
              title_fontsize = fontsize)
    if ymax is None:
        _, ymax = ax.get_ylim()
    ax.set_ylim(0, ymax)
    
    return ax

########################
## Growth Curve Plots ##
########################

def gc_plot(gc_data, pq, color_dict = None, ax = None,
            legend = False, linewidth = 0.75, legendsize = 7, 
            labelsize = 7, ticksize = 7, ylim = 1.3):
    """
    Plots growth curves for fig 4M
    
    Parameters
    ----------
    gc_data: growth curve data input
    pq: paraquat level to plot
    color_dict: colors for each strain; defaults provided
    ax: axes to plot to
    legend: whether or not to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    ylim: max value of y axis
    
    Returns
    -------
    ax: axes with plot
    """
    
    # organize the data
    meta_cols = ['strain', 'pq']
    gc_meta = gc_data[meta_cols]
    gc_data = gc_data.drop(meta_cols, axis = 1)
    gc_data.columns = gc_data.columns.astype(float)/3600
    
    # get relevant rows
    group = gc_meta.loc[gc_meta.pq == pq]
    
    # use default vals if necessary
    if color_dict is None:
        color_dict = {'0_0': 'tab:blue',
              '0_0 pitA::pitA*': 'tab:orange',
              '1_0': 'tab:red',
              '1_0 pitA*::pitA': 'tab:purple'}
    if ax is None:
        fig, ax = plt.subplots()
    
    # plot
    for g in group.index:
        l = group.loc[g, 'strain']
        ax.plot(gc_data.columns, gc_data.loc[g],
                label = l, color = color_dict[l],
                linewidth = linewidth)
    
    # clean up
    ax.set_ylim(0, ylim)
    ax.set_title(str(pq)+ ' Î¼M PQ', fontsize = labelsize)
    if legend:
        ax.legend(bbox_to_anchor=(1,1), fontsize = legendsize)
    if True:
        ax.set_ylabel('OD', fontsize = labelsize)
        ax.set_xlabel('Time [hr]', fontsize = labelsize)
    ax.tick_params(labelsize = ticksize)
    
    return ax


#######################
## Metabolomic Plots ##
#######################

def met_bar_swarm(final_rates, ros_meta, k, strain_dict = None, ax = None,
              orientation = 'vertical', dodge = True, legend = False,
              legendsize = 7, labelsize = 7, ticksize = 7, 
              errwidth = 1, pointsize = 1.5, x_rot = 90,
              zerolinewidth = 0.5):
    """
    Generates bar/swarm plots for iModulon activities
    Relies on seaborn's bar and swarm functions
    
    Parameters
    ----------
    final_rates: table of metabolomic data
    ros_meta: main metadata
    k: column in final_rates to plot
    strain_dict: dictionary with labels pointing to lists of strains
                 default: start vs. evolved
    ax: axes to plot to (will create one if not provided)
    orientation: 'horizontal' or 'vertical'
    dodge: Whether to separate each PQ level into different bars
    legend: Whether to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    pointsize: point size for swarm plot
    x_rot: rotation of x axis labels
    
    Returns
    -------
    ax: axes with plot
    """
    
    # organize groups of strains
    if strain_dict is None:
        strain_dict = {'Start':['0_0'],
                       'Evolved':get_ev_strains(ros_meta)}
    sample_dict = {label: final_rates.index[final_rates.my_strain.isin(strains1)] 
                   for label, strains1 in strain_dict.items()}

    # make data table for seaborn
    data = pd.DataFrame(columns = ['x_label', 'y', 'Lineage', 'PQ'])
    for label, samples in sample_dict.items():
        for s in samples:
            data.loc[s] = [label, final_rates.loc[s, k], 
                           final_rates.my_strain[s],
                           final_rates.pq[s]]
    if (data.y <= 0).all():
        data.y = -data.y
        
    axis_label = k.replace('_', ' ')
    
    # use my main plotting function
    ax =  main_plotter(data, sample_dict, axis_label, ax,
                       orientation, dodge, legend, legendsize,
                       labelsize, ticksize, errwidth, pointsize,
                       x_rot, zerolinewidth)
    return ax

#################
## Other Plots ##
#################

def special_bar_swarm(ica, ros_meta, input_data, column, strain_dict = None,
                      ax = None, orientation = 'vertical', dodge = True,
                      legend = False, legendsize = 7, labelsize = 7, ticksize = 7, 
                      errwidth = 1.5, pointsize = 1.5, x_rot = 90,
                      zerolinewidth = 0.5):
    """
    Generates bar/swarm plots for special data, 
        such as the distances to the Fur Trendline
    Relies on seaborn's bar and swarm functions
    
    Parameters
    ----------
    ica, ros_meta: main object & metadata
    input data: table of input data where each row is a sample in ica
    column: column for value to plot from input_data
    strain_dict: dictionary with labels pointing to lists of strains
                 default: start vs. evolved
    ax: axes to plot to (will create one if not provided)
    orientation: 'horizontal' or 'vertical'
    dodge: Whether to separate each PQ level into different bars
    legend: Whether to draw the legend
    legendsize: fontsize for the legend
    labelsize: fontsize for the axis labels
    ticksize: fontsize for the tick labels on the axes
    err_width: width of errorbars in barplot
    pointsize: point size for swarm plot
    x_rot: rotation of x axis labels
    zerolinewidth: width of the line at 0
    
    Returns
    -------
    ax: axes with plot
    """
    
    # organize groups of strains
    if strain_dict is None:
        strain_dict = {'Start':['0_0'],
                       'Evolved':get_ev_strains(ros_meta)}
    sample_dict = {label: get_samples(ros_meta, strains, [0, 250, 750]) 
                   for label, strains in strain_dict.items()}

    # make data table for seaborn
    data = pd.DataFrame(columns = ['x_label', 'y', 'Lineage', 'PQ'])
    for label, samples in sample_dict.items():
        for s in samples:
            data.loc[s] = [label, input_data.T.loc[column, s], 
                           ros_meta.lineage[s],
                           ros_meta.pq[s]]
                           
    axis_label = column
    
    # use my main plotting function
    ax =  main_plotter(data, sample_dict, axis_label, ax,
                       orientation, dodge, legend, legendsize,
                       labelsize, ticksize, errwidth, pointsize,
                       x_rot, zerolinewidth)
    return ax